# Сревис для работы с запросами в тех поддержку
### Сервис предоставляет базовые структуры для взаимодействия с http запросами и их обработки

Разработчик: [Lamer](https://github.com/ThisIsLamer)

## Запуск, сборка проекта
### Разработка
```cmd
npm run dev
```
Он использует nodemon для мониторинга изменений в директории в кроссплатформенной среде, для запуска Typescript приложения используется ts-node.

### Деплой
Обязательно перед сборкой убедитесь, что у вас правильно заполнен файл `.env` по образцу из `.env.example`, а так же правильно задана конфигурация http сервера в файле `fastify.config.json` и `multipart.config.json`. Конфигурация `multipart` нужна для указания парамтеров передаваемых обьектов на сервер: размер и количество файлов.
```cmd
npm run buid && node dist/src/index.js
```
Данная команда компилирует исходный Typescript код в Javascript с параметрами указанными в tsconfig.json.

## Разработка
### Описание структуры
Основная страктура проекта выглядит следующим образом.
```
Project
├── src\
│   ├── core\
│   │   ├── hooks\
│   │   │   ├── auth.ts
│   │   │   ├── roles.ts
│   │   │   └── route.ts
│   │   ├── base.ts
│   │   ├── fastify.ts
│   │   ├── jsonRPC.ts
│   │   ├── mongoose.ts
│   │   ├── redis.ts
│   │   └── rest.ts
│   ├── modules\
│   │   ├── app\
│   │   └── ...\
│   ├── index.ts
│   └── modules.ts
├── types\
│   ├── custom-types.d.ts
│   └── env.d.ts
├── garbage\
├── .env
├── fastify.config.json
├── multipart.config.json
├── fastify.config.json
├── package.json
├── package-lock.json
└── tsconfig.json
```
В проекте есть ядро, оно включает в себя базовый функционал для запуска проекта, а так же для обработки http запросов.

В директории src/core/hooks хранятся функции, которые внедряются в жизненный цикл запроса во время выполнения [`preHandler`](https://fastify.dev/docs/latest/Reference/Lifecycle/). Данную директорию можно дополнять своими функциями для домолнительной обработки запроса.

`src/core`
файлы `fastify.ts`, `mongoose.ts`, `redis.ts` занимаются созданием экземполяров своих обьектов и созданием соединения, для предоставления дальнейшего функционала для работы с ними.

### Fastify
Экземпляр обьекта fastify можно использовать импортировав его экземпляр в переменной `server` из файла `fastify.ts`, во время стандартной разработки это пригодится не должно, испорт этого обьета выходимт за рамки стандартного использования, поэтому импортировать его для дальнейшей работы не рекомендуется, если это происходит за пределами директории  `src/core`.

### Redis
Для работы с редис, достаточно импортировать его экземпляр в перемененой `redisClient` из файла `src/index.ts`. Он предоставляет полный API для работы с Redis согласно [документации](https://github.com/redis/node-redis?tab=readme-ov-file).

### MongoDB
Для работы с MongoDB используется ORM mongoose, она предоставляет API интерфейс для быстрого и удобного создания запроса в базу данных. Экземпляр обьекта доступен в переменной `mongoClient` из файла `src/index.ts`. Он предоставляет полный API для работы с MongoDB согласно [документации](https://mongoosejs.com/docs/guide.html).

### Создание конечной точки
Все конечные точки находятся в директории `src/modules` в директории со своим модулем.

Модуль состоит из `контроллера (*.controller.ts)`, `модели (*.model.ts)`, `сервиса (*.service.ts)`

Контроллер обрабатывает http запросы пользователя, работает с базой данных, так же может взаимодействовать с сервисами и моделями. Если контроллеру нужно использовать повторяющийся функционал из другого сервиса, он может импортировать экземпляр этого сервиса из файла `src/services.ts` и использовать нужную функцию. Так же контроллеры могут использовать модели из других модулей, если это необходимо.

Сервис включает в себя часто используемые функции в контроллерах, что бы не реализовывать несколько раз обно и то же, можно просто импортировать функцию из сервиса, которая сама всё сделает.

Модель это сущность базы данных, она описывает структуру этой сущности, её зависимости, тип полей, а так же предоставляет апи для работы с ней в базе данных.

Для создания конечной точки, нужно использовать специальный декоратор: `@Post()`, `@Get()`, `@Put()`, `@Delete()`, в аргументах декоратора указать путь, который будет использоваться через RestAPI. Пример `@Post('/chat/create')` RestAPI -> `http://localhost:3000/chat/create`. Можно сделать то же самое, но через декоратор `@Route()`, он принимает 2 аргумента `(method: string, path: string)` метод запроса и путь, хотя его можно использовать, но это не рекомендуется делать, так как такой подход ухудшает читаемость кода и является плохой практикой. Все эти декораторы не могут использоваться в паре и должны находится в самом верху над остальными декораторами, пример:

src/modules/app/app.controller.ts
```typescript
@Get('/about')
@Public()
getAbout() {
  return 'this about page`;
}
```

Все запросы проходят этап авторизации по заголовку `Authorization`, который должен содержать действующий токен, после чего обьект аккаунта пользователя помещается в `request.user`, если нужно убрать авторизацию с запроса, то можно испольовать декоратор `@Public()`, но нужно помнить, что в `request.user` будет пусто. Публичный запрос не подразумевает работы с пользователем и обработки пользовтаельских данных. Так же этот декоратор не совместим с декоратором `@Roles()`.

Если нужно сделать метод, доступ к которому будут иметь пользователи обладающие конкретной ролью, или ролями, то можно использовать декоратор `@Roles` он принимает `...args` для обработки набора разрешённых ролей запроса. Пример использования: `@Roles('support', 'admin')` доступ к роуту будет иметь пользователь, который будет иметь хотя бы одну из этих ролей.

Для работы в формами, файлами, можно поменять тип запроса на [Multipart](https://github.com/fastify/fastify-multipart), с помощью декоратора `@DefineFastifyMultipart()`, он не принимает никаких аргументов, только меняет тип метода и добавляет проверку, если пользователь отправит на этот метод запрос, который не является `Multipart` запросом, то он получит ошибку `The request type does not match the method type, multipart is expected`. `Multipart` запросы позмоляют использовать следующие декораторы в аргументах функции: `@File()`, `@Files()`, `@Form()`.

* `@File()` принимает аргумент `name` и не может использоваться без него, этот аргумент соответствует названию поля (`fieldname`).

* `@Files()` так же принимает аргументы названия полей, но так же может использоваться без аргументов, в таком случае в переменную вернутся все поля из формы соответствующие типу `file`

* `@Form()`принимает аргумент `name`, но может использоваться и без аргументов, тогда в переменную вернутся все поля из формы типа `field`.

Пример использования:

src/modules/files/files.controller.ts
```typescript
export class FileController {
  @Post('/files')
  @DefineFastifyMultipart()
  async uploadFiles(
    @Request() request: FastifyRequest,
    @Reply() reply: FastifyReply,

    @Form('messageId') messageId: MultipartValue<string>,
    @Files() files: MultipartFile[]
  ) { }
}
```

Все конечные точки могут так же использовать в своих аргументах декораторы: `@Query()`, `@Body()`, `@Request()`, `@Reply()`.
* `@Query()` Этот декоратор позволяет получить данные из Query переменной в запросе, принимает название этой переменной.

* `@Body()` Этот декоратор позволяет получить даные из Body переменной в запросе, принимает название переменной.

* `@Request()` Этот декоратор передаёт request обьект, соответствующий типу [`FastifyRequest`](https://fastify.dev/docs/latest/Reference/Request/)

* `@Reply()` этот декоратор передаёт reply обьект, соответствующий типу [`@FastifyReply`](https://fastify.dev/docs/latest/Reference/Reply/)

Пример использования

// Сохранение с использованием метода Post
```typescript
export class CatsController {
  @Post('/cats')
  async cats(
    @Request() request: FastifyRequest,
    @Reply() reply: FastifyReply,

    @Body('name') name: string
  ) { 
    // ... save cat name in variable loadedCat
    return jsonRPC.success({ cat: loadedCat })'
  }
}
```

// Получение с использованием метода Get
```typescript
export class CatsController {
  @Get('/cats')
  async cats(
    @Request() request: FastifyRequest,
    @Reply() reply: FastifyReply,

    @Query('name') name: string
  ) { 
    // ... get cat by name and save in variable loadedCat
    return jsonRPC.success({ cat: loadedCat });
  }
}
```